<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Project Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900 h-screen w-screen">
  <div class="flex flex-col h-screen w-screen min-h-0">
    <!-- Header: project title + status badge -->
    <header class="flex items-center justify-between px-4 py-3 border-b bg-white">
      <div class="flex items-center gap-2">
        <a href="/" class="text-sky-600 underline">← Back</a>
        <h1 id="chatProjectTitle" class="text-lg font-semibold">Project</h1>
        <span id="chatProjectStatus"></span>
      </div>
      <div class="text-xs text-slate-500">Live agent updates</div>
    </header>

    <!-- Content area: markdown output + agent events -->
    <main class="flex-1 flex flex-col min-h-0">
      <section class="flex-1 overflow-y-auto p-4" id="chatOutput">
        <!-- Chat/LLM markdown-rendered messages go here -->
      </section>

      <!-- Bottom input row -->
      <footer class="border-t bg-white p-3">
        <div id="chatTags" class="mb-2 flex flex-wrap gap-2"></div>
        <form id="chatForm" class="flex items-end gap-2">
          <textarea id="chatInput" class="flex-1 border rounded px-3 py-2 min-h-[44px]" rows="2" placeholder="Ask about requirements or propose changes..."></textarea>
          <button id="chatSend" class="px-4 py-2 bg-indigo-600 text-white rounded">Send</button>
        </form>
        <div id="chatHint" class="text-xs text-slate-500 mt-1">Shift+Enter for newline, Enter to send.</div>
      </footer>
    </main>
  </div>

  <script type="module">
    'use strict';
    // Simple markdown renderer: supports headings, bold, italics, code fences, lists, links
    function renderMarkdown(md) {
      let html = (md || '').replace(/[&<>]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]));
      html = html
        .replace(/^###\s+(.*)$/gm, '<h3 class="text-base font-semibold mt-3">$1</h3>')
        .replace(/^##\s+(.*)$/gm, '<h2 class="text-lg font-semibold mt-4">$1</h2>')
        .replace(/^#\s+(.*)$/gm, '<h1 class="text-xl font-bold mt-5">$1</h1>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1<\/strong>')
        .replace(/\*(.*?)\*/g, '<em>$1<\/em>')
        .replace(/`([^`]+)`/g, '<code class="bg-slate-100 px-1 rounded">$1<\/code>')
        .replace(/```([\s\S]*?)```/g, '<pre class="bg-slate-900 text-slate-100 p-3 rounded overflow-auto"><code>$1<\/code><\/pre>')
        .replace(/^\s*[-*]\s+(.*)$/gm, '<li class="list-disc ml-6">$1<\/li>')
        .replace(/\[(.+?)\]\((https?:[^\s]+)\)/g, '<a href="$2" target="_blank" class="text-sky-600 underline">$1<\/a>');
      // Wrap orphan list items
      html = html.replace(/(<li[\s\S]*?<\/li>)/g, '<ul>$1<\/ul>');
      return html;
    }

    function getStatusBadge(status) {
      const s = (status || '').toLowerCase();
      const base = 'inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ';
      let cls = 'bg-slate-100 text-slate-700';
      if (s === 'processing') cls = 'bg-blue-100 text-blue-700';
      else if (s === 'active') cls = 'bg-emerald-100 text-emerald-700';
      else if (s === 'rag_processing') cls = 'bg-teal-100 text-teal-700';
      else if (s === 'rag_ready') cls = 'bg-green-100 text-green-700';
      else if (s.includes('failed') || s === 'rag_failed') cls = 'bg-rose-100 text-rose-700';
      const span = document.createElement('span');
      span.className = base + cls;
      span.textContent = s || 'unknown';
      return span;
    }

    const chatOutput = document.getElementById('chatOutput');
    const chatForm = document.getElementById('chatForm');
    const chatInput = document.getElementById('chatInput');
    const chatTags = document.getElementById('chatTags');
    const projectTitleEl = document.getElementById('chatProjectTitle');
    const projectStatusEl = document.getElementById('chatProjectStatus');

    const state = { config: null, token: null, projectId: null, project: null, boxesByPromptId: {}, thinkingBoxes: [], activeBox: null, pendingBox: null };

    function scrollToBottom() { chatOutput.scrollTop = chatOutput.scrollHeight; }

    function appendUserMessage(text) {
      const wrap = document.createElement('div');
      wrap.className = 'mb-3';
      wrap.innerHTML = `<div class="text-xs text-slate-500 mb-1">You</div><div class="bg-white border rounded p-3">${renderMarkdown(text)}</div>`;
      chatOutput.appendChild(wrap); scrollToBottom();
    }

    function appendModelMessage(md, meta) {
      const wrap = document.createElement('div');
      wrap.className = 'mb-3';
      const header = meta ? `<div class="text-xs text-slate-500 mb-1">${meta}</div>` : '';
      wrap.innerHTML = `${header}<div class="bg-slate-50 border rounded p-3">${renderMarkdown(md)}</div>`;
      chatOutput.appendChild(wrap); scrollToBottom();
    }

    function appendAssistantHtml(html, meta) {
      const wrap = document.createElement('div');
      wrap.className = 'mb-3';
      const header = meta ? `<div class="text-xs text-slate-500 mb-1">${meta}</div>` : '';
      wrap.innerHTML = `${header}<div class="bg-slate-50 border rounded p-3">${html}</div>`;
      chatOutput.appendChild(wrap); scrollToBottom();
    }

    // Thinking box UI helpers
    function createThinkingBox(promptId = null) {
      const wrap = document.createElement('details');
      wrap.className = 'thinking-box border rounded p-3 relative my-3 bg-transparent text-slate-500';
      wrap.open = true;

      const summary = document.createElement('summary');
      summary.className = 'cursor-pointer select-none text-xs text-slate-500 pr-8';
      summary.innerText = 'Agent thought stream';

      const pill = document.createElement('span');
      pill.className = 'pill absolute -top-2 left-2 text-[10px] px-2 py-0.5 rounded bg-slate-50 text-slate-600 ring-2 ring-slate-200 animate-pulse';
      pill.textContent = 'Thinking…';
      summary.appendChild(pill);

      const messages = document.createElement('div');
      messages.className = 'mt-2 space-y-1 messages text-sm text-slate-500';

      wrap.appendChild(summary);
      wrap.appendChild(messages);
      chatOutput.appendChild(wrap);
      scrollToBottom();

      const startedAt = Date.now();
      const box = {
        promptId: promptId,
        element: wrap,
        setPromptId(newId) {
          if (!newId) return;
          this.promptId = newId;
          state.boxesByPromptId[newId] = this;
        },
        appendStream(text) {
          if (!text) return;
          const line = document.createElement('div');
          line.textContent = String(text);
          messages.appendChild(line);
          scrollToBottom();
        },
        appendMarkdown(md) {
          if (!md) return;
          const line = document.createElement('div');
          line.className = 'text-slate-500';
          line.innerHTML = renderMarkdown(String(md));
          messages.appendChild(line);
          scrollToBottom();
        },
        finish(status = 'ok') {
          const seconds = Math.max(0, Math.round((Date.now() - startedAt) / 1000));
          pill.textContent = `Thinked ${seconds}s`;
          pill.className = 'pill absolute -top-2 left-2 text-[10px] px-2 py-0.5 rounded bg-slate-50 text-slate-500';
          if (status !== 'ok') {
            pill.className += ' ring-2 ring-rose-200 text-rose-700 bg-rose-50';
          }
          wrap.open = false;
        }
      };

      state.thinkingBoxes.push(box);
      if (promptId) state.boxesByPromptId[promptId] = box;
      state.activeBox = box;
      return box;
    }

    function getOrCreateBoxForPromptId(promptId) {
      if (!promptId) return state.activeBox || state.pendingBox || createThinkingBox(null);
      if (state.boxesByPromptId[promptId]) return state.boxesByPromptId[promptId];
      // If there is a pending box without id, bind it
      if (state.pendingBox && !state.pendingBox.promptId) {
        state.pendingBox.setPromptId(promptId);
        const b = state.pendingBox; state.pendingBox = null; state.activeBox = b; return b;
      }
      return createThinkingBox(promptId);
    }

    async function loadConfig() {
      const r = await fetch('/config'); state.config = await r.json();
    }

    async function fetchDevToken() {
      try { const t = await fetch('/dev-token', { method: 'POST' }).then(r=>r.json()); state.token = t.access_token || null; } catch {}
    }

    async function loadProject() {
      const id = location.hash ? location.hash.substring(1) : '';
      state.projectId = id;
      if (!id) return;
      const base = state.config.projectManagementApiBase.replace(/\/$/, '');
      const res = await fetch(`${base}/projects/${id}`, { headers: state.token ? { 'Authorization': `Bearer ${state.token}` } : {} });
      if (!res.ok) return;
      state.project = await res.json();
      projectTitleEl.textContent = state.project.name || '(untitled)';
      projectStatusEl.innerHTML = ''; projectStatusEl.appendChild(getStatusBadge(state.project.status));
    }

    function setupInputBehavior() {
      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); chatForm.requestSubmit(); }
      });
      chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = chatInput.value.trim();
        if (!text) return;
        appendUserMessage(text);
        chatInput.value = '';
        state.currentPrompt = text;
        // start a pending thinking box immediately
        const pending = createThinkingBox(null);
        state.pendingBox = pending;
        // Send to AI Workflow requirements endpoint
        try {
          const base = state.config.aiWorkflowApiBase.replace(/\/$/, '');
          const headers = { 'Content-Type': 'application/json' };
          if (state.token) headers['Authorization'] = `Bearer ${state.token}`;
          const res = await fetch(`${base}/requirements`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ project_id: state.projectId, prompt: text })
          });
          if (res.ok) {
            const bundle = await res.json();
            state.currentBundle = bundle;
            appendAssistantHtml(renderBundleHtml(bundle), 'Assistant • Requirements');
            updateTags(bundle);
            if (Array.isArray(bundle.clarification_questions) && bundle.clarification_questions.length) {
              wireClarificationsHandlers(bundle);
            }
            // finalize the thinking box linked to this prompt
            const pid = bundle.prompt_id;
            if (pending && !pending.promptId && pid) pending.setPromptId(pid);
            const box = (pid && state.boxesByPromptId[pid]) ? state.boxesByPromptId[pid] : pending;
            if (box) box.finish('ok');
          } else {
            appendModelMessage('Error: failed to generate requirements', 'System');
            if (state.pendingBox) { state.pendingBox.finish('error'); state.pendingBox = null; }
          }
        } catch (err) {
          appendModelMessage('Network error while contacting AI workflow', 'System');
          if (state.pendingBox) { state.pendingBox.finish('error'); state.pendingBox = null; }
        }
      });
    }

    function subscribeSSE() {
      const es = new EventSource('/events');
      // Listen for orchestrator AI workflow progress messages
      es.addEventListener('ai_workflow_progress', (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          if (!state.projectId || String(state.projectId) !== String(msg.project_id)) return;
          // Update status badge from orchestrator status
          projectStatusEl.innerHTML = '';
          projectStatusEl.appendChild(getStatusBadge(msg.status));
          // Route thought summary into a thinking box correlated by prompt_id
          const md = msg.details_md || msg.thought_summary || '...';
          const pid = msg.prompt_id || null;
          const box = getOrCreateBoxForPromptId(pid);
          if (box) box.appendMarkdown(md);
        } catch {}
      });
    }

    function renderBundleHtml(bundle) {
      const esc = (s) => String(s ?? '').replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
      const list = (arr) => (Array.isArray(arr) && arr.length)
        ? `<ul class="list-disc ml-5 space-y-1 text-sm text-slate-700">${arr.map(i=>`<li>${esc(i)}</li>`).join('')}</ul>`
        : '<div class="text-slate-500 text-sm">None</div>';

      const priorityPill = (p) => {
        const val = String(p || '').toLowerCase();
        let cls = 'bg-slate-100 text-slate-700 border-slate-200';
        if (val === 'must') cls = 'bg-amber-50 text-amber-700 border-amber-200';
        else if (val === 'should') cls = 'bg-sky-50 text-sky-700 border-sky-200';
        else if (val === 'could') cls = 'bg-emerald-50 text-emerald-700 border-emerald-200';
        return `<span class="inline-flex items-center px-2 py-0.5 rounded border ${cls} text-xs">${esc(p)}</span>`;
      };

      const reqs = (items) => (Array.isArray(items) && items.length) ? items.map((r, idx) => `
        <div class="border rounded-md p-3 bg-white">
          <div class="text-base font-semibold leading-snug">${esc(r.title || `Requirement ${idx+1}`)}</div>
          <div class="mt-1 text-sm text-slate-700">${esc(r.description || '')}</div>
          <div class="mt-2 text-sm">
            <span class="font-semibold">Priority:</span>
            <span class="align-middle ml-1">${priorityPill(r.priority)}</span>
          </div>
          <div class="mt-2">
            <div class="text-sm font-semibold mb-1">Acceptance Criteria</div>
            ${list(r.acceptance_criteria)}
          </div>
        </div>
      `).join('') : '<div class="text-slate-500 text-sm">None</div>';

      let html = `
        <div class="mt-2">
          <div class="text-xs uppercase tracking-wide text-slate-500 mb-2">Business Requirements</div>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-3">${reqs(bundle.business_requirements)}</div>
        </div>
        <div class="mt-4">
          <div class="text-xs uppercase tracking-wide text-slate-500 mb-2">Functional Requirements</div>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-3">${reqs(bundle.functional_requirements)}</div>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
          <div>
            <div class="text-sm font-semibold mb-1">Assumptions</div>
            ${list(bundle.assumptions)}
          </div>
          <div>
            <div class="text-sm font-semibold mb-1">Risks</div>
            ${list(bundle.risks)}
          </div>
        </div>
        
        <div class="mt-2 text-sm">Score <span class="inline-flex items-center px-2 py-0.5 rounded bg-emerald-50 text-emerald-700 border border-emerald-200">${esc(bundle.score)}</span></div>
      `;

      return html;
    }

    function renderTagsHtml(bundle) {
      const esc = (s) => String(s ?? '').replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
      const actions = Number(bundle.score) > 0.7
        ? `<button data-action="subtasks" class="inline-flex items-center px-2 py-1 rounded-full border text-xs text-slate-700 hover:bg-slate-50">Create Sub-tasks</button>`
        : `<button data-action="answer" class="inline-flex items-center px-2 py-1 rounded-full border text-xs text-slate-700 hover:bg-slate-50">Answer Questions</button>`;
      return `<div id="actions_${esc(bundle.prompt_id)}" class="flex flex-wrap gap-2">${actions}</div>`;
    }

    function updateTags(bundle) {
      if (!bundle || !chatTags) return;
      chatTags.innerHTML = renderTagsHtml(bundle);
      wireActionTags(bundle);
    }

    function wireActionTags(bundle) {
      const host = document.getElementById(`actions_${bundle.prompt_id}`);
      if (!host) return;
      host.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const action = btn.getAttribute('data-action');
        if (action === 'answer') {
          const count = Array.isArray(bundle.clarification_questions) ? bundle.clarification_questions.length : 0;
          const lines = Array.from({ length: count }, (_, i) => `${i + 1}.`).join('\n');
          const template = `Here are answers on questions to increase score:\n${lines}`;
          chatInput.value = template;
          chatInput.focus();
        } else if (action === 'subtasks') {
          appendModelMessage('Create Sub-tasks action triggered', 'System');
          try {
            document.dispatchEvent(new CustomEvent('create-subtasks', { detail: { bundle: bundle, projectId: state.projectId } }));
          } catch {}
        }
      });
    }

    function wireClarificationsHandlers(bundle) {
      const container = document.getElementById(`clarify_${bundle.prompt_id}`);
      if (!container) return;
      const btn = container.querySelector('button.clarify-submit');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        btn.disabled = true; btn.classList.add('opacity-50');
        // collect answers
        const answers = [];
        (bundle.clarification_questions || []).forEach(q => {
          const el = container.querySelector(`[name="q_${q.id}"]`);
          if (el && el.value) answers.push({ id: q.id, answer: String(el.value) });
        });
        try {
          const base = state.config.aiWorkflowApiBase.replace(/\/$/, '');
          const headers = { 'Content-Type': 'application/json' };
          if (state.token) headers['Authorization'] = `Bearer ${state.token}`;
          // start a pending thinking box for answers flow
          const pending = createThinkingBox(null);
          state.pendingBox = pending;
          const res = await fetch(`${base}/answers`, {
            method: 'POST',
            headers,
            body: JSON.stringify({
              project_id: state.projectId,
              prompt_id: bundle.prompt_id,
              prompt: state.currentPrompt || '',
              answers
            })
          });
          if (res.ok) {
            const nextBundle = await res.json();
            state.currentBundle = nextBundle;
            appendAssistantHtml(renderBundleHtml(nextBundle), 'Assistant • Updated Requirements');
            updateTags(nextBundle);
            if (Array.isArray(nextBundle.clarification_questions) && nextBundle.clarification_questions.length) {
              wireClarificationsHandlers(nextBundle);
            }
            const pid = nextBundle.prompt_id;
            if (pending && !pending.promptId && pid) pending.setPromptId(pid);
            const box = (pid && state.boxesByPromptId[pid]) ? state.boxesByPromptId[pid] : pending;
            if (box) box.finish('ok');
          } else {
            appendModelMessage('Error: failed to submit answers', 'System');
            if (state.pendingBox) { state.pendingBox.finish('error'); state.pendingBox = null; }
          }
        } catch (err) {
          appendModelMessage('Network error while submitting answers', 'System');
          if (state.pendingBox) { state.pendingBox.finish('error'); state.pendingBox = null; }
        } finally {
          btn.disabled = false; btn.classList.remove('opacity-50');
        }
      });
    }

    (async function init(){
      await loadConfig();
      await fetchDevToken();
      await loadProject();
      setupInputBehavior();
      subscribeSSE();
    })().catch(console.error);
  </script>
</body>
</html>